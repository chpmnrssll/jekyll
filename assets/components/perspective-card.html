<html>
  <template id="template">
    <style>
      :host {
        display: block;
        perspective: 25rem;
        /*overflow: hidden;*/
      }
      .container {
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform-style: preserve-3d;
        will-change: transform opacity;
        -webkit-transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        -moz-transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        -o-transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        -webkit-transition: transform var(--animation-speed) ease-out;
        -moz-transition: transform var(--animation-speed) ease-out;
        -o-transition: transform var(--animation-speed) ease-out;
        transition: transform var(--animation-speed) ease-out;
      }
      /* gradient overlay */
      .container::before {
        content: "";
        width: 100%;
        height: 100%;
        opacity: 0.15;
        position: absolute;
        transform-style: preserve-3d;
        will-change: transform opacity;
        background: linear-gradient(135deg, var(--color-primary-light9) 0%, var(--color-primary) 100%);
        -webkit-transform: translateZ(-1rem) scale(1.05);
        -moz-transform: translateZ(-1rem) scale(1.05);
        -o-transform: translateZ(-1rem) scale(1.05);
        transform: translateZ(-1rem) scale(1.05);
      }
      .background-image {
        box-shadow: 0.25rem 0.25rem 2rem var(--color-primary-dark5);
        top: 0%;
        z-index: -1;
        width: 100%;
        height: 100%;
        position: absolute;
        transform-style: preserve-3d;
        will-change: transform opacity;
        -webkit-transform: translateZ(-1rem) scale(1.05);
        -moz-transform: translateZ(-1rem) scale(1.05);
        -o-transform: translateZ(-1rem) scale(1.05);
        transform: translateZ(-1rem) scale(1.05);
      }
      ::slotted(*) {
        transform-style: preserve-3d;
      }
    </style>
    <div class="container"><slot></slot></div>
  </template>
  <script>
    const importDocument = document.currentScript.ownerDocument;
    const animationSpeed = parseInt(window.getComputedStyle(document.documentElement).getPropertyValue("--animation-speed").slice(0, -2));

    customElements.define("perspective-card", class extends HTMLElement {
      constructor() {
        super();
        this.template = importDocument.querySelector("#template");
        this.shadow = this.attachShadow({ mode: "open" });
        this.shadow.appendChild(this.template.content.cloneNode(true));
        this.container = this.shadow.querySelector(".container");
      }

      connectedCallback() {
        this.addEventListener("mousemove", (event) => {
          // save this events target, then wait for a new frame
          const currentTarget = event.target;
          requestAnimationFrame(() => {
            const width = currentTarget.clientWidth;
            const height = currentTarget.clientHeight;

            // offset from center of card, range(-0.5, 0.5)
            const scrollOffset = currentTarget.offsetParent.offsetTop + currentTarget.offsetTop - window.pageYOffset;
            const xOffset = ((event.clientX - this.offsetLeft) / width) - 0.5;
            const yOffset = ((event.clientY - scrollOffset) / height) - 0.5;

            // set CSS custom properties
            this.style.setProperty("--x-offset", xOffset);
            this.style.setProperty("--y-offset", yOffset);
          });
        }, { passive: true });

        this.addEventListener("mouseleave", (event) => {
          const currentTarget = event.currentTarget;

          // reset card rotation after animationSpeed ms
          setTimeout(() => {
            currentTarget.style.setProperty("--x-offset", 0);
            currentTarget.style.setProperty("--y-offset", 0);
          }, animationSpeed * 2);
        }, { passive: true });
      }

      static get observedAttributes() {
        return [ "background-image" ];
      }

      attributeChangedCallback(attr, oldValue, newValue) {
        //console.log(attr, oldValue, newValue);
        if (attr === "background-image") {
          if (!this.parallaxImage) {
            this.parallaxImage = new Image();
          }
          this.parallaxImage.classList.add("background-image")
          this.parallaxImage.src = newValue;
          this.container.appendChild(this.parallaxImage);
        }
      }
    });
  </script>
</html>
