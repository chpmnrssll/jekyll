<html>
  <template id="template">
    <style>
      :host {
        display: block;
        perspective: 25rem;
        /*overflow: hidden;*/
      }
      .container {
        width: 100%;
        height: 100%;
        pointer-events: none;
        transform-style: preserve-3d;
        box-shadow: 0px 0px 32px var(--color-primary-dark5);
        -webkit-transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        -moz-transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        -o-transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        transform: rotateY(calc(var(--x-offset) * -35deg)) rotateX(calc(var(--y-offset) * 35deg));
        -webkit-transition: all var(--animation-speed) ease-out;
        -moz-transition: all var(--animation-speed) ease-out;
        -o-transition: all var(--animation-speed) ease-out;
        transition: all var(--animation-speed) ease-out;
      }
      /* gradient overlay */
      .container::before {
        content: "";
        opacity: 0.3;
        width: 100%;
        height: 100%;
        position: absolute;
        background: linear-gradient(315deg, var(--color-primary-dark5) 0%, var(--color-primary-light1) 100%);
      }
      .background-image {
        z-index: -1;
        top: 0%;
        width: 100%;
        height: 100%;
        position: absolute;
        transform-style: preserve-3d;
      }
      ::slotted(*) {
        transform-style: preserve-3d;
        -webkit-transform: translateZ(1rem);
        -moz-transform: translateZ(1rem);
        -o-transform: translateZ(1rem);
        transform: translateZ(1rem);
      }
    </style>
    <div class="container">
      <slot></slot>
    </div>
  </template>
  <script>
    customElements.define("perspective-card", class extends HTMLElement {
      constructor() {
        super();
        this.importDocument = document.currentScript.ownerDocument;
        this.template = this.importDocument.querySelector("#template");
        this.shadow = this.attachShadow({ mode: "open" });
        this.shadow.appendChild(this.template.content.cloneNode(true));
        this.container = this.shadow.querySelector(".container");
      }

      connectedCallback() {
        this.addEventListener("mousemove", (event) => {

          // save this events target, then wait for a new frame
          const currentTarget = event.target;
          requestAnimationFrame(() => {
            const width = currentTarget.clientWidth;
            const height = currentTarget.clientHeight;

            // offset from center of card, range(-0.5, 0.5)
            const scrollOffset = currentTarget.offsetParent.offsetTop + currentTarget.offsetTop - window.pageYOffset;
            const xOffset = ((event.clientX - this.offsetLeft) / width) - 0.5;
            const yOffset = ((event.clientY - scrollOffset) / height) - 0.5;

            // set CSS custom properties/variables
            this.style.setProperty("--x-offset", xOffset);
            this.style.setProperty("--y-offset", yOffset);
          });
        }, { passive: true });

        this.addEventListener("mouseleave", (event) => {
          const currentTarget = event.currentTarget;
          const animationSpeed = parseInt(window.getComputedStyle(document.documentElement).getPropertyValue("--animation-speed").slice(0, -2));
          setTimeout(() => {
            // reset card rotation
            currentTarget.style.setProperty("--x-offset", 0);
            currentTarget.style.setProperty("--y-offset", 0);
          }, animationSpeed);
        }, { passive: true });

      }

      static get observedAttributes() {
        return [ "background-image" ];
      }

      attributeChangedCallback(attr, oldValue, newValue) {
        //console.log(attr, oldValue, newValue);
        if (attr === "background-image") {
          if (!this.parallaxImage) {
            this.parallaxImage = new Image();
            this.parallaxImage.classList.add("background-image")
          }
          this.parallaxImage.src = newValue;
          this.container.appendChild(this.parallaxImage);
        }
      }
    });
  </script>
</html>
